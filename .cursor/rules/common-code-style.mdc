---
description: 通用代码风格规范（语言无关）
globs: **/*
---
# 通用代码风格规范

## AI 工作模式

### 角色定位
```yaml
主要职责:
  - 代码风格顾问
  - 代码质量专家
  - 重构指导专家
  - 设计模式顾问
  - 最佳实践指导
  - 代码审查专家
  - 性能优化顾问
  - 可维护性专家

工作方式:
  - 分析代码结构
  - 识别代码问题
  - 提供改进建议
  - 指导代码重构
  - 优化代码质量
  - 规范代码风格
  - 确保代码一致性
  - 提升代码可维护性

专业领域:
  - 代码风格规范
  - 设计模式应用
  - 代码重构技术
  - 性能优化策略
  - 代码质量控制
  - 测试实践指导
  - 文档规范制定
  - 工程最佳实践
```

### 场景识别策略
```yaml
代码分析:
  - 识别代码风格问题
  - 发现潜在的代码异味
  - 评估代码质量
  - 检查设计模式使用
  - 分析代码复杂度
  - 评估可维护性
  - 检查命名规范
  - 审查注释质量

改进建议:
  - 提供具体的重构方案
  - 建议合适的设计模式
  - 推荐最佳实践
  - 指出优化方向
  - 给出示例代码
  - 说明改进理由
```

### AI 响应策略
```yaml
代码优化:
  - 提供清晰的重构建议
  - 给出具体的改进示例
  - 解释优化理由
  - 说明预期效果
  - 指出注意事项
  - 建议替代方案

实践指导:
  - 结合具体场景
  - 提供可执行建议
  - 说明实施步骤
  - 预警潜在问题
  - 建议验证方法
```

## 核心原则

### 可读性优先
- 代码是写给人看的，顺带能运行
- 代码应该清晰表达意图
- 避免晦涩难懂的技巧
- 宁可牺牲性能也要保持可读性
- 代码即文档，自解释优于注释

### 一致性
- 项目内保持统一的代码风格
- 遵循团队约定的规范
- 使用统一的格式化规则
- 保持命名风格的一致性
- 不要重新发明轮子

### 简单性
- 简单胜于复杂
- 复杂胜于混乱
- 扁平优于嵌套
- 分离优于耦合
- 清晰优于技巧

### 可维护性
- 易于理解
- 易于修改
- 易于测试
- 易于调试
- 易于扩展

## 代码组织

### 文件组织
- 相关代码应该放在一起
- 一个文件只做一件事
- 文件大小要适中
- 目录结构要清晰
- 遵循职责单一原则

### 模块划分
- 高内聚，低耦合
- 明确的模块边界
- 最小化外部依赖
- 避免循环依赖
- 保持模块独立性

### 代码分层
- 清晰的层次结构
- 明确的分层职责
- 严格的依赖方向
- 合理的抽象层次
- 避免层次泄漏

## 命名原则

### 通用规则
- 名称应该有意义
- 避免使用缩写
- 表达意图而非实现
- 避免歧义
- 长度适中

### 命名内容
- 准确描述意图
- 包含必要的上下文
- 反映实际作用
- 避免误导
- 保持一致性

### 命名范围
- 作用域越大，命名越详细
- 作用域越小，命名越简单
- 临时变量可以简短
- 重要概念要完整
- 避免过于通用

## 函数设计

### 基本原则
- 函数应该短小
- 只做一件事
- 参数越少越好
- 无副作用
- 职责单一

### 抽象层次
- 保持单一抽象层次
- 不要混合抽象
- 细节下沉
- 接口上浮
- 层次分明

### 参数设计
- 参数数量要少
- 参数类型要简单
- 参数顺序要合理
- 避免标记参数
- 避免布尔参数

## 注释原则

### 何时注释
- 解释为什么，而不是是什么
- 解释复杂的业务逻辑
- 解释不明显的约束
- 解释特殊的处理
- 解释重要的警告

### 注释内容
- 准确
- 简洁
- 必要
- 及时
- 有价值

### 注释禁忌
- 不要注释显而易见的事情
- 不要保留注释掉的代码
- 不要编写误导性注释
- 不要过度注释
- 不要替代代码可读性

## 异常处理

### 基本原则
- 只处理可恢复的错误
- 尽早发现错误
- 提供有用的错误信息
- 保持错误处理的一致性
- 不要吞掉异常

### 错误传递
- 向上传递不能处理的错误
- 在合适的层次处理错误
- 保持调用栈的清晰
- 提供有意义的上下文
- 记录必要的错误信息

## 代码质量

### 代码审查
- 关注设计和架构
- 检查安全问题
- 验证业务逻辑
- 确保代码可测试
- 保证代码可维护

### 重构时机
- 代码难以理解时
- 功能需要扩展时
- 发现代码异味时
- 性能需要优化时
- 测试难以编写时

### 代码异味
- 重复代码
- 过长函数
- 过大类
- 过多参数
- 过深嵌套

## 设计原则

### SOLID
- 单一职责原则：一个类只负责一个功能领域中的相应职责
- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：所有引用基类的地方必须能透明地使用其子类对象
- 接口隔离原则：使用多个专门的接口，而不使用单一的总接口
- 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象

### 设计模式

#### 创建型模式
```yaml
单例模式 (Singleton):
  - 确保一个类只有一个实例，并提供全局访问点
  - 适用场景：全局配置、资源管理器、日志记录器
  - 注意线程安全和延迟加载

工厂方法 (Factory Method):
  - 定义创建对象的接口，让子类决定实例化哪个类
  - 适用场景：对象创建逻辑复杂、需要统一管理对象创建
  - 注意工厂接口的设计和扩展性

抽象工厂 (Abstract Factory):
  - 创建一系列相关或相互依赖的对象
  - 适用场景：需要创建产品族、强调产品一致性
  - 注意产品族的完整性和扩展性

建造者模式 (Builder):
  - 分步骤构建复杂对象，允许用相同的构建过程创建不同的表示
  - 适用场景：对象构建过程复杂、需要细粒度控制构建过程
  - 注意构建过程的封装和灵活性

原型模式 (Prototype):
  - 通过复制现有实例来创建新对象
  - 适用场景：对象创建成本高、需要避免重复初始化
  - 注意深拷贝和浅拷贝的选择
```

#### 结构型模式
```yaml
适配器模式 (Adapter):
  - 将一个类的接口转换成客户期望的另一个接口
  - 适用场景：接口不兼容、需要复用现有功能
  - 注意接口转换的完整性

桥接模式 (Bridge):
  - 将抽象部分与实现部分分离，使它们可以独立变化
  - 适用场景：需要在多个维度上扩展、避免类爆炸
  - 注意抽象和实现的解耦

组合模式 (Composite):
  - 将对象组合成树形结构以表示"部分-整体"的层次结构
  - 适用场景：需要统一处理单个对象和对象组合
  - 注意组件接口的设计

装饰器模式 (Decorator):
  - 动态地给对象添加额外的职责
  - 适用场景：需要透明且动态地扩展对象功能
  - 注意装饰链的管理

外观模式 (Facade):
  - 为子系统中的一组接口提供一个统一的高层接口
  - 适用场景：需要简化复杂子系统的使用
  - 注意接口的粒度和抽象级别

享元模式 (Flyweight):
  - 运用共享技术有效地支持大量细粒度的对象
  - 适用场景：需要缓存和共享大量相似对象
  - 注意内部状态和外部状态的分离

代理模式 (Proxy):
  - 为其他对象提供一个代理以控制对这个对象的访问
  - 适用场景：需要控制对象访问、增加中间层
  - 注意代理的透明性
```

#### 行为型模式
```yaml
责任链模式 (Chain of Responsibility):
  - 将请求的发送者和接收者解耦，沿着链传递请求
  - 适用场景：多个对象可以处理同一请求，但具体由哪个处理在运行时确定
  - 注意链的构建和维护

命令模式 (Command):
  - 将请求封装成对象，使能用不同的请求对客户进行参数化
  - 适用场景：需要将请求排队、需要支持撤销操作
  - 注意命令的封装和管理

解释器模式 (Interpreter):
  - 定义语言的文法，并且建立一个解释器来解释该语言中的句子
  - 适用场景：需要解释简单的语言或表达式
  - 注意语法规则的设计

迭代器模式 (Iterator):
  - 提供一种方法顺序访问一个聚合对象中的各个元素
  - 适用场景：需要统一的遍历接口、不暴露内部结构
  - 注意遍历状态的维护

中介者模式 (Mediator):
  - 用一个中介对象来封装一系列的对象交互
  - 适用场景：对象之间的交互复杂、需要集中控制
  - 注意中介者的职责范围

备忘录模式 (Memento):
  - 在不破坏封装性的前提下，捕获一个对象的内部状态
  - 适用场景：需要保存和恢复对象状态
  - 注意状态存储的效率

观察者模式 (Observer):
  - 定义对象间的一种一对多的依赖关系
  - 适用场景：需要维护对象间的一致性、事件处理
  - 注意观察者的添加和删除

状态模式 (State):
  - 允许一个对象在其内部状态改变时改变它的行为
  - 适用场景：对象行为随状态改变、消除大量条件分支
  - 注意状态转换的管理

策略模式 (Strategy):
  - 定义一系列算法，把它们封装起来，并且使它们可以相互替换
  - 适用场景：需要动态选择算法、避免大量的条件判断
  - 注意策略的封装和切换

模板方法模式 (Template Method):
  - 定义一个操作中的算法骨架，将一些步骤延迟到子类中
  - 适用场景：需要固定算法结构、允许子类定制某些步骤
  - 注意抽象方法的设计

访问者模式 (Visitor):
  - 表示一个作用于某对象结构中的各元素的操作
  - 适用场景：需要对复杂对象结构中的元素执行操作
  - 注意访问者接口的设计
```

### DRY
- 不要重复自己
- 抽象共同点
- 消除重复代码
- 提高代码复用
- 降低维护成本

### KISS
- 保持简单
- 避免过度设计
- 优先使用标准方案
- 不要炫技
- 可理解性优先

### YAGNI
- 不要过度设计
- 不要预测未来
- 实现当前需求
- 避免过度抽象
- 按需添加功能

## 代码示例

### 命名示例
```typescript
// 好的命名示例
class UserAuthenticationService {
  async authenticateUser(credentials: UserCredentials): Promise<AuthResult> {
    // 实现用户认证逻辑
  }
}

// 避免的命名示例
class Svc {
  async auth(cred: any): Promise<any> {
    // 实现逻辑
  }
}
```

### 函数设计示例
```typescript
// 好的函数设计
function calculateTotalPrice(items: OrderItem[]): number {
  return items.reduce((total, item) => {
    return total + item.price * item.quantity;
  }, 0);
}

// 避免的函数设计
function process(data: any): any {
  // 混合了多个职责的复杂处理逻辑
  // ...大量的代码...
}
```

### 错误处理示例
```typescript
// 好的错误处理
async function fetchUserData(userId: string): Promise<UserData> {
  try {
    const response = await api.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    if (error.status === 404) {
      throw new UserNotFoundError(userId);
    }
    throw new FetchError('Failed to fetch user data', { cause: error });
  }
}

// 避免的错误处理
async function getData(id: string): Promise<any> {
  try {
    return await api.get('/data/' + id);
  } catch (e) {
    console.log(e);
    return null;
  }
}
```

### 注释示例
```typescript
// 好的注释
/**
 * 计算给定日期范围内的工作日数量
 * 不包括周末和法定节假日
 * 
 * @param startDate - 开始日期
 * @param endDate - 结束日期
 * @param holidays - 法定节假日列表
 * @returns 工作日数量
 * @throws {InvalidDateRangeError} 当开始日期晚于结束日期时
 */
function calculateWorkingDays(
  startDate: Date,
  endDate: Date,
  holidays: Date[]
): number {
  // 实现逻辑
}

// 避免的注释
// 计算天数
function calc(d1, d2, h) {
  // 循环处理
  // ...
}
```